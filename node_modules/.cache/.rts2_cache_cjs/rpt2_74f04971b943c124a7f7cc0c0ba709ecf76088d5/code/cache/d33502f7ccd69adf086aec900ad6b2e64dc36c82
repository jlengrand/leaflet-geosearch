{"code":"import AbstractProvider from './provider';\r\nexport default class Provider extends AbstractProvider {\r\n    endpoint() {\r\n        // No query, Algolia requires POST request\r\n        return 'https://places-dsn.algolia.net/1/places/query';\r\n    }\r\n    /**\r\n     * Find index of value with best match\r\n     * (full, fallback to partial, and then to 0)\r\n     */\r\n    findBestMatchLevelIndex(vms) {\r\n        const match = vms.find((vm) => vm.matchLevel === 'full') ||\r\n            vms.find((vm) => vm.matchLevel === 'partial');\r\n        return match ? vms.indexOf(match) : 0;\r\n    }\r\n    /**\r\n     * Algolia not provides labels for hits, so\r\n     * we will implement that builder ourselves\r\n     */\r\n    getLabel(result) {\r\n        return [\r\n            // Building + Street\r\n            result.locale_names?.default[this.findBestMatchLevelIndex(result._highlightResult.locale_names.default)],\r\n            // City\r\n            result.city?.default[this.findBestMatchLevelIndex(result._highlightResult.city.default)],\r\n            // Administrative (State / Province)\r\n            result.administrative[this.findBestMatchLevelIndex(result._highlightResult.administrative)],\r\n            // Zip code / Postal code\r\n            result.postcode?.[this.findBestMatchLevelIndex(result._highlightResult.postcode)],\r\n            // Country\r\n            result.country?.default,\r\n        ]\r\n            .filter(Boolean)\r\n            .join(', ');\r\n    }\r\n    parse(response) {\r\n        return response.data.hits.map((r) => ({\r\n            x: r._geoloc.lng,\r\n            y: r._geoloc.lat,\r\n            label: this.getLabel(r),\r\n            bounds: null,\r\n            raw: r,\r\n        }));\r\n    }\r\n    async search({ query }) {\r\n        const params = typeof query === 'string' ? { query } : query;\r\n        const request = await fetch(this.endpoint(), {\r\n            method: 'POST',\r\n            body: JSON.stringify({\r\n                ...this.options.params,\r\n                ...params,\r\n            }),\r\n        });\r\n        const json = await request.json();\r\n        return this.parse({ data: json });\r\n    }\r\n}\r\n//# sourceMappingURL=algoliaProvider.js.map","references":["/Users/julienlengrand-lambert/Developer/leaflet-geosearch/src/providers/provider.ts"],"map":"{\"version\":3,\"file\":\"algoliaProvider.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/providers/algoliaProvider.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,gBAKN,MAAM,YAAY,CAAC;AAuDpB,MAAM,CAAC,OAAO,OAAO,QAAS,SAAQ,gBAGrC;IACC,QAAQ;QACN,0CAA0C;QAC1C,OAAO,+CAA+C,CAAC;IACzD,CAAC;IAED;;;OAGG;IACH,uBAAuB,CAAC,GAAiB;QACvC,MAAM,KAAK,GACT,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,UAAU,KAAK,MAAM,CAAC;YAC1C,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,UAAU,KAAK,SAAS,CAAC,CAAC;QAChD,OAAO,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACxC,CAAC;IAED;;;OAGG;IACH,QAAQ,CAAC,MAAiB;QACxB,OAAO;YACL,oBAAoB;YACpB,MAAM,CAAC,YAAY,EAAE,OAAO,CAC1B,IAAI,CAAC,uBAAuB,CAC1B,MAAM,CAAC,gBAAgB,CAAC,YAAY,CAAC,OAAO,CAC7C,CACF;YACD,OAAO;YACP,MAAM,CAAC,IAAI,EAAE,OAAO,CAClB,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,OAAO,CAAC,CACnE;YACD,oCAAoC;YACpC,MAAM,CAAC,cAAc,CACnB,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,gBAAgB,CAAC,cAAc,CAAC,CACrE;YACD,yBAAyB;YACzB,MAAM,CAAC,QAAQ,EAAE,CACf,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAC/D;YACD,UAAU;YACV,MAAM,CAAC,OAAO,EAAE,OAAO;SACxB;aACE,MAAM,CAAC,OAAO,CAAC;aACf,IAAI,CAAC,IAAI,CAAC,CAAC;IAChB,CAAC;IAED,KAAK,CAAC,QAAsC;QAC1C,OAAO,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;YACpC,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG;YAChB,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG;YAChB,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YACvB,MAAM,EAAE,IAAI;YACZ,GAAG,EAAE,CAAC;SACP,CAAC,CAAC,CAAC;IACN,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,EAAE,KAAK,EAAkB;QACpC,MAAM,MAAM,GAAG,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;QAE7D,MAAM,OAAO,GAAG,MAAM,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE;YAC3C,MAAM,EAAE,MAAM;YACd,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC;gBACnB,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM;gBACtB,GAAG,MAAM;aACV,CAAC;SACH,CAAC,CAAC;QAEH,MAAM,IAAI,GAAG,MAAM,OAAO,CAAC,IAAI,EAAE,CAAC;QAClC,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;IACpC,CAAC;CACF\"}","dts":{"name":"/Users/julienlengrand-lambert/Developer/leaflet-geosearch/providers/algoliaProvider.d.ts","writeByteOrderMark":false,"text":"import AbstractProvider, { LatLng, ParseArgument, SearchArgument, SearchResult } from './provider';\r\ninterface RequestResult {\r\n    hits: RawResult[];\r\n}\r\ninterface ValueMatch {\r\n    value: string;\r\n    matchLevel: string;\r\n    matchedWords: string[];\r\n    fullyHighlighted?: boolean;\r\n}\r\ninterface RawResult {\r\n    country: {\r\n        [key: string]: string;\r\n    };\r\n    country_code: string;\r\n    city: {\r\n        [key: string]: string[];\r\n    };\r\n    importance: number;\r\n    _tags: string[];\r\n    postcode: string[];\r\n    population: number;\r\n    is_country: boolean;\r\n    is_highway: boolean;\r\n    is_city: boolean;\r\n    is_popular: boolean;\r\n    administrative: string[];\r\n    admin_level: number;\r\n    is_suburb: boolean;\r\n    locale_names: {\r\n        default: string[];\r\n    };\r\n    _geoloc: LatLng;\r\n    objectID: string;\r\n    _highlightResult: {\r\n        country: {\r\n            default: ValueMatch;\r\n            [key: string]: ValueMatch;\r\n        };\r\n        city: {\r\n            default: ValueMatch[];\r\n            [key: string]: ValueMatch[];\r\n        };\r\n        postcode: ValueMatch[];\r\n        administrative: ValueMatch[];\r\n        locale_names: {\r\n            default: ValueMatch[];\r\n        };\r\n    };\r\n}\r\nexport default class Provider extends AbstractProvider<RequestResult, RawResult> {\r\n    endpoint(): string;\r\n    /**\r\n     * Find index of value with best match\r\n     * (full, fallback to partial, and then to 0)\r\n     */\r\n    findBestMatchLevelIndex(vms: ValueMatch[]): number;\r\n    /**\r\n     * Algolia not provides labels for hits, so\r\n     * we will implement that builder ourselves\r\n     */\r\n    getLabel(result: RawResult): string;\r\n    parse(response: ParseArgument<RequestResult>): SearchResult<RawResult>[];\r\n    search({ query }: SearchArgument): Promise<SearchResult<RawResult>[]>;\r\n}\r\nexport {};\r\n"}}
