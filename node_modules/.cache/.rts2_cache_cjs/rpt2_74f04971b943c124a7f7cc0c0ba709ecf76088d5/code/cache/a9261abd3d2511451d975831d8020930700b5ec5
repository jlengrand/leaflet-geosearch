{"code":"import AbstractProvider, { RequestType, } from './provider';\r\nexport default class PeliasProvider extends AbstractProvider {\r\n    constructor(options = {}) {\r\n        super(options);\r\n        this.host = options.host || 'http://localhost:4000';\r\n    }\r\n    /**\r\n     * note: Pelias has four different query modes:\r\n     * /v1/autocomplete: for partially completed inputs (such as when a user types)\r\n     * /v1/search: for completed inputs (such as when geocoding a CSV file)\r\n     * /v1/search/structured: for completed inputs with fields already separated\r\n     * /v1/reverse: for finding places nearby/enveloping a point\r\n     */\r\n    endpoint({ query, type }) {\r\n        switch (type) {\r\n            // case RequestType.AUTOCOMPLETE:\r\n            //   const autocompleteParams = (typeof query === 'string') ? { text: query } : query;\r\n            //   return this.getUrl(`${this.host}/v1/autocomplete`, autocompleteParams);\r\n            // case RequestType.FULLTEXT:\r\n            //   const searchParams = (typeof query === 'string') ? { text: query } : query;\r\n            //   return this.getUrl(`${this.host}/v1/search`, searchParams);\r\n            // case RequestType.STRUCTURED:\r\n            //   const structuredParams = (typeof query === 'string') ? { address: query } : query;\r\n            //   return this.getUrl(`${this.host}/v1/search/structured`, structuredParams);\r\n            case RequestType.REVERSE:\r\n                const reverseParams = typeof query === 'string' ? {} : query;\r\n                return this.getUrl(`${this.host}/v1/reverse`, reverseParams);\r\n            // note: the default query mode is set to 'autocomplete'\r\n            default:\r\n                const autocompleteParams = typeof query === 'string' ? { text: query } : query;\r\n                return this.getUrl(`${this.host}/v1/autocomplete`, autocompleteParams);\r\n        }\r\n    }\r\n    parse(response) {\r\n        return response.data.features.map((feature) => {\r\n            const res = {\r\n                x: feature.geometry.coordinates[0],\r\n                y: feature.geometry.coordinates[1],\r\n                label: feature.properties.label,\r\n                bounds: null,\r\n                raw: feature,\r\n            };\r\n            // bbox values are only available for features derived from non-point geometries\r\n            // geojson bbox format: [minX, minY, maxX, maxY]\r\n            if (Array.isArray(feature.bbox) && feature.bbox.length === 4) {\r\n                res.bounds = [\r\n                    [feature.bbox[1], feature.bbox[0]],\r\n                    [feature.bbox[3], feature.bbox[2]],\r\n                ];\r\n            }\r\n            return res;\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=peliasProvider.js.map","references":["/Users/julienlengrand-lambert/Developer/leaflet-geosearch/src/providers/provider.ts"],"map":"{\"version\":3,\"file\":\"peliasProvider.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/providers/peliasProvider.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,gBAAgB,EAAE,EAIvB,WAAW,GAEZ,MAAM,YAAY,CAAC;AAsFpB,MAAM,CAAC,OAAO,OAAO,cAAe,SAAQ,gBAG3C;IAQC,YAAY,UAAiC,EAAE;QAC7C,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,IAAI,uBAAuB,CAAC;IACtD,CAAC;IAED;;;;;;OAMG;IACH,QAAQ,CAAC,EAAE,KAAK,EAAE,IAAI,EAAoB;QACxC,QAAQ,IAAI,EAAE;YACZ,iCAAiC;YACjC,sFAAsF;YACtF,4EAA4E;YAE5E,6BAA6B;YAC7B,gFAAgF;YAChF,gEAAgE;YAEhE,+BAA+B;YAC/B,uFAAuF;YACvF,+EAA+E;YAE/E,KAAK,WAAW,CAAC,OAAO;gBACtB,MAAM,aAAa,GAAG,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;gBAC7D,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,IAAI,aAAa,EAAE,aAAa,CAAC,CAAC;YAE/D,wDAAwD;YACxD;gBACE,MAAM,kBAAkB,GACtB,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;gBACtD,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,IAAI,kBAAkB,EAAE,kBAAkB,CAAC,CAAC;SAC1E;IACH,CAAC;IAED,KAAK,CAAC,QAAsC;QAC1C,OAAO,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE;YAC5C,MAAM,GAAG,GAA4B;gBACnC,CAAC,EAAE,OAAO,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC;gBAClC,CAAC,EAAE,OAAO,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC;gBAClC,KAAK,EAAE,OAAO,CAAC,UAAU,CAAC,KAAK;gBAC/B,MAAM,EAAE,IAAI;gBACZ,GAAG,EAAE,OAAO;aACb,CAAC;YAEF,gFAAgF;YAChF,gDAAgD;YAChD,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC5D,GAAG,CAAC,MAAM,GAAG;oBACX,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAClC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;iBACnC,CAAC;aACH;YAED,OAAO,GAAG,CAAC;QACb,CAAC,CAAC,CAAC;IACL,CAAC;CACF\"}","dts":{"name":"/Users/julienlengrand-lambert/Developer/leaflet-geosearch/providers/peliasProvider.d.ts","writeByteOrderMark":false,"text":"import AbstractProvider, { EndpointArgument, ParseArgument, ProviderOptions, SearchResult } from './provider';\r\nexport interface RequestResult {\r\n    geocoding: object;\r\n    features: RawResult[];\r\n}\r\nexport declare type PeliasProviderOptions = {\r\n    host?: string;\r\n} & ProviderOptions;\r\nexport interface RawResult {\r\n    type: 'Feature';\r\n    geometry: {\r\n        type: 'Point';\r\n        coordinates: [number, number];\r\n    };\r\n    bbox?: [number, number, number, number];\r\n    properties: {\r\n        id: string;\r\n        source_id: string;\r\n        gid: string;\r\n        layer: string;\r\n        source: string;\r\n        label: string;\r\n        name: string;\r\n        accuracy: 'centroid' | 'point';\r\n        confidence?: number;\r\n        match_type?: 'exact' | 'interpolated' | 'fallback';\r\n        borough?: string;\r\n        borough_a?: string;\r\n        borough_gid?: string;\r\n        continent?: string;\r\n        continent_a?: string;\r\n        continent_gid?: string;\r\n        country?: string;\r\n        country_a?: string;\r\n        country_gid?: string;\r\n        county?: string;\r\n        county_a?: string;\r\n        county_gid?: string;\r\n        dependency?: string;\r\n        dependency_a?: string;\r\n        dependency_gid?: string;\r\n        empire?: string;\r\n        empire_a?: string;\r\n        empire_gid?: string;\r\n        localadmin?: string;\r\n        localadmin_a?: string;\r\n        localadmin_gid?: string;\r\n        locality?: string;\r\n        locality_a?: string;\r\n        locality_gid?: string;\r\n        macrocounty?: string;\r\n        macrocounty_a?: string;\r\n        macrocounty_gid?: string;\r\n        macroregion?: string;\r\n        macroregion_a?: string;\r\n        macroregion_gid?: string;\r\n        marinearea?: string;\r\n        marinearea_a?: string;\r\n        marinearea_gid?: string;\r\n        neighbourhood?: string;\r\n        neighbourhood_a?: string;\r\n        neighbourhood_gid?: string;\r\n        ocean?: string;\r\n        ocean_a?: string;\r\n        ocean_gid?: string;\r\n        postalcode?: string;\r\n        postalcode_a?: string;\r\n        postalcode_gid?: string;\r\n        region?: string;\r\n        region_a?: string;\r\n        region_gid?: string;\r\n        street?: string;\r\n        housenumber?: string;\r\n        addendum?: any;\r\n    };\r\n}\r\nexport default class PeliasProvider extends AbstractProvider<RequestResult, RawResult> {\r\n    host: string;\r\n    constructor(options?: PeliasProviderOptions);\r\n    /**\r\n     * note: Pelias has four different query modes:\r\n     * /v1/autocomplete: for partially completed inputs (such as when a user types)\r\n     * /v1/search: for completed inputs (such as when geocoding a CSV file)\r\n     * /v1/search/structured: for completed inputs with fields already separated\r\n     * /v1/reverse: for finding places nearby/enveloping a point\r\n     */\r\n    endpoint({ query, type }: EndpointArgument): string;\r\n    parse(response: ParseArgument<RequestResult>): SearchResult<RawResult>[];\r\n}\r\n"}}
